import type { Appearance, CommercePlanResource, CommerceSubscriptionPlanPeriod, CommerceSubscriptionResource } from '@clerk/types';
import type { LocalizationKey } from '../../localization';
export declare const usePaymentSourcesCacheKey: () => {
    key: string;
    resourceId: string | undefined;
};
export declare const usePaymentMethods: () => {
    data: import("@clerk/types").CommercePaymentSourceResource[];
    count: number;
    error: import("@clerk/shared/error").ClerkAPIResponseError | null;
    isLoading: boolean;
    isFetching: boolean;
    isError: boolean;
    page: number;
    pageCount: number;
    fetchPage: (size: number | ((_size: number) => number)) => void;
    fetchPrevious: () => void;
    fetchNext: () => void;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    revalidate: () => Promise<void>;
    setData: (data?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentSourceResource> | ((currentData?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentSourceResource> | undefined) => import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentSourceResource> | Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentSourceResource> | undefined> | undefined) | undefined) => Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentSourceResource> | undefined>;
};
export declare const usePaymentAttempts: () => {
    data: import("@clerk/types").CommercePaymentResource[];
    count: number;
    error: import("@clerk/shared/error").ClerkAPIResponseError | null;
    isLoading: boolean;
    isFetching: boolean;
    isError: boolean;
    page: number;
    pageCount: number;
    fetchPage: (size: number | ((_size: number) => number)) => void;
    fetchPrevious: () => void;
    fetchNext: () => void;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    revalidate: () => Promise<void>;
    setData: (data?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentResource> | ((currentData?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentResource> | undefined) => import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentResource> | Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentResource> | undefined> | undefined) | undefined) => Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommercePaymentResource> | undefined>;
};
export declare const useStatements: (params?: {
    mode: "cache";
}) => {
    data: import("@clerk/types").CommerceStatementResource[];
    count: number;
    error: import("@clerk/shared/error").ClerkAPIResponseError | null;
    isLoading: boolean;
    isFetching: boolean;
    isError: boolean;
    page: number;
    pageCount: number;
    fetchPage: (size: number | ((_size: number) => number)) => void;
    fetchPrevious: () => void;
    fetchNext: () => void;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    revalidate: () => Promise<void>;
    setData: (data?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommerceStatementResource> | ((currentData?: import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommerceStatementResource> | undefined) => import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommerceStatementResource> | Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommerceStatementResource> | undefined> | undefined) | undefined) => Promise<import("@clerk/types").ClerkPaginatedResponse<import("@clerk/types").CommerceStatementResource> | undefined>;
};
export declare const useSubscriptions: () => {
    error: any;
    mutate: import("swr").KeyedMutator<import("@clerk/types").ClerkPaginatedResponse<CommerceSubscriptionResource> | undefined>;
    isValidating: boolean;
    isLoading: boolean;
    data: CommerceSubscriptionResource[];
};
export declare const usePlans: () => import("swr").SWRResponse<CommercePlanResource[], any, {
    dedupingInterval: number;
    keepPreviousData: boolean;
}>;
type HandleSelectPlanProps = {
    plan: CommercePlanResource;
    planPeriod: CommerceSubscriptionPlanPeriod;
    onSubscriptionChange?: () => void;
    mode?: 'modal' | 'mounted';
    event?: React.MouseEvent<HTMLElement>;
    appearance?: Appearance;
    newSubscriptionRedirectUrl?: string;
};
export declare const usePlansContext: () => {
    activeOrUpcomingSubscription: (plan: CommercePlanResource) => CommerceSubscriptionResource | undefined;
    activeAndUpcomingSubscriptions: (plan: CommercePlanResource) => CommerceSubscriptionResource[];
    activeOrUpcomingSubscriptionBasedOnPlanPeriod: (plan: CommercePlanResource, planPeriod?: CommerceSubscriptionPlanPeriod) => CommerceSubscriptionResource | undefined;
    isDefaultPlanImplicitlyActiveOrUpcoming: boolean;
    handleSelectPlan: ({ plan, planPeriod, onSubscriptionChange, mode, event, appearance, newSubscriptionRedirectUrl, }: HandleSelectPlanProps) => void;
    buttonPropsForPlan: ({ plan, subscription: sub, isCompact, selectedPlanPeriod, }: {
        plan?: CommercePlanResource;
        subscription?: CommerceSubscriptionResource;
        isCompact?: boolean;
        selectedPlanPeriod?: CommerceSubscriptionPlanPeriod;
    }) => {
        localizationKey: LocalizationKey;
        variant: "bordered" | "solid";
        colorScheme: "secondary" | "primary";
        isDisabled: boolean;
        disabled: boolean;
    };
    canManageSubscription: ({ plan, subscription: sub }: {
        plan?: CommercePlanResource;
        subscription?: CommerceSubscriptionResource;
    }) => boolean;
    captionForSubscription: (subscription: CommerceSubscriptionResource) => LocalizationKey;
    upcomingSubscriptionsExist: boolean;
    defaultFreePlan: CommercePlanResource | undefined;
    revalidateAll: () => void;
};
export {};
